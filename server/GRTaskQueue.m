#import "GRTaskQueue.h"
#import "GRResource.h"

@implementation GRTaskQueue
@synthesize resources;

+ (GRTaskQueue*)sharedQueue
{
    static dispatch_once_t once;
    static GRTaskQueue* sharedQueue;
    dispatch_once(&once, ^{ 
            sharedQueue = [[self alloc] init]; 
    });
    return sharedQueue;
}

- (oneway void)release {}
- (NSUInteger)retainCount { return NSUIntegerMax; }
- (id)retain { return self; }
- (id)autorelease { return self; }

- (id)init
{
    self = [super init];
    if (self != nil) {
        self.maxConcurrentOperationCount = 5;
        self.resources = [NSMutableDictionary dictionary];
    }
    return self;
}

- (void)addTask:(GRTask*)task 
       importer:(Class<GRImporter>)Importer
      resources:(NSArray*)requiredResources
completionBlock:(GRImportCompletionBlock)complete
{
    NSDictionary* taskInfo = [task dictionaryRepresentation];
    GRImportCompletionBlock done = [complete copy];

    [self addOperationWithBlock:^{
        NSLog(@"start operation");

        // ask plugin to generate an import block for this task
        GRImportOperationBlock import = [Importer newImportBlock];

        // acquire resource locks
        [GRResource acquireResources:requiredResources];

        // execute import block generated by plugin
        NSError* error = nil;
        BOOL status = import(taskInfo, &error);

        // unlock resources
        [GRResource relinquishResources:requiredResources];

        // execute the completion block
        done(status, error);

        // clean up
        [complete release];
        [import release];

        NSLog(@"stop operation");
    }];
}

@end
